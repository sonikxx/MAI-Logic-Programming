# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Шевлякова С. С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Список в Prolog является набором некоторых объектов, он состоит из 2 частей: головы (первый элемент списка) и присоединенного хвоста (все последующие элементы), хвост тоже можно представить в виде головы и хвоста, поэтому обработка списка происходит рекурсивно. Обрабатывая список, мы отделяем голову, выполняем с ней необходимые действия, и переходим к хвосту списка, у которого снова отделяем голову и повторяем аналогичные действия, так происходит, пока список не останется пустым. Стоит помнить, что пустой список это тоже список, поэтому при создании предиката обязательно надо прописать правило обработки пустого списка. Для раздления списка на голову и хвост используется специальный символ - `|`. Списки в Prolog напоминают бинарное дерево, каждый узел которого обязательно имеет лист, самым нижним элементом такого дерево будет являться пустой список. Также список напоминает стек: мы имеем быстрый доступ к первому элементу, но для получения n-ого элемента требуется n операций. 

В отличие от принятых в императивных языках подходов к хранению данных, Prolog позволяет смешение разных типов данных в одном списке, элементы списка могут быть любыми. Помимого этого в списках нет необходимости объявлять размерность перед созданием.

## Задание 1.0: Реализация стандратных предикатов

`length(L,N)` - предикат находит длину N списка L.

`member(X,L)` - предикат проверяет принадлежность переменной X к списку L.

`append(L,L1,R)` - предикат, реализующий конкатенацию списков L и L1, получая список R.

`remove(X,L,R)` - предикат удаляет элемент X из списка L, получая список R.

`permute(L,L1)` - предикат, резализующий всевозможные перестановки списка L в L1.

`sublist(S,L)` - предикат проверяет является ли S подсписком L.

Реализация:
```prolog
length([],0).
length([_|T],N):-
    length(T,N1),
    N1 is N - 1.
    
memeber(H,[H|_]).
memeber(X, [_|T]):-
    memeber(X,T).
    
append([],X,X).
append([H|T],L,[H|R]):-
    append(T,L,R).
    
remove(H,[H|T],T).
remove(X,[H|T],[H|T1]):-
    remove(X,T,T1).

permute([],[]).
permute(L,[H|T]):-
    remove(H,L,R),
    permute(R,T).
    
sublist(S,L):-
  append(_,L1,L),
  append(S,_,L1).
```

Примеры использования:
```prolog
?- length([1,3,a,d,f],X).
X = 5.
?- memeber(2,[a,b,c,d,2,3]).
true .
?- append([1,2,3],[a,b,c],X).
X = [1, 2, 3, a, b, c].
?- remove(a,[1,2,a,b,3],X).
X = [1, 2, b, 3] ;
false.
?- sublist([a,b],[1,2,a,b,c]).
true
?- permute([1,2,3],X).
X = [1, 2, 3] ;
X = [1, 3, 2] ;
X = [2, 1, 3] ;
X = [2, 3, 1] ;
X = [3, 1, 2] ;
X = [3, 2, 1] ;
false.
```


## Задание 1.1: Предикат обработки списка

`remove_n(N,L,L1)` - предикат remove_n удаляет элемент с номером N из списка L, получая список L1. Если N = 0, то список не изменяется. Если N = 1, мы должны удалить первый элемент, для этого удаляем просто голову списка. Если же N > 1, то используем рекурсию, и теперь рассматриваем предикат remove_n от хвоста списка, при этом позиция нужного нам элемента уменьшается на 1.

`remove_n1(N,L,L1)` - предикат аналогичен `remove_n`, но реализован при помощи стандартных предикатов. Когда N > 1, нужный нам элемент будет разделять список на 2 части. При помощи двух предикатов append, мы можем представить нужный нам элемент в качестве анонимной переменной, обозначаемой `_` Также мы должны проверить, что длина части спика, находящейся перед удаляемым элементом будет на 1 меньше номера самого элемента.

Примеры использования:
```prolog
?- remove_n(4,[a,b,c,d,e],X).
X = [a, b, c, e].
?- remove_n1(3,[a,b,c,d,e],X).
X = [a, b, d, e] 
```

Реализация:
```prolog
% без применения стандарных предикатов
remove_n(0,L,L):-!.
remove_n(1,[_|L],L):-!.
remove_n(N,[Y|L],[Y|L1]):-
    N1 is N - 1,
    remove_n(N1,L,L1).

% с применением стандартных предикатов 
remove_n1(0,L,L):-!.
remove_n1(1,[_|L],L):-!.
remove_n1(N,R,R1):-
    append(Y,[_|L],R),
    append(Y,L,R1),
    N1 is N - 1,
    length(Y,N1).
```


## Задание 1.2: Предикат обработки числового списка

`first_negative(N,L)` - предикат, выисляющий позицию N первого отрицательного элемента в числовом списке L. Если в голове списка лежит отрицательный элемент, то N = 1. Если же первый элемент списка не будет являтьмя отрицательным, то мы рекурсивно вызываем предикат `first_negative` уже от хвоста спика, при этом позиция элемента уменьшиться на 1. Как только отрицательный элемент окажется в голове списка, программа прекратит дальнейший поиск.

`first_negative1(N,L)` - предикат аналогичен `first_negative`, но реализован при помощи стандартных предикатов. Когда первый отрицательный элемент лежит не в голове списка, мы рекурсивно вызываем предикат `first_negative1` от хвоста списка. Благодаря проверке на длину списка и условию положительного значения в голове, программа остановится, когда найдет первый отрицательный элемент.

`remove_negative(L,L1)` - предикат удаляет первый отрицательный элемент из списка L, и мы получаем список L1. При помощи предиката `first_negative` мы находим позицию первого отрицательного элемента в списке. А потом, используя предикат `remove_n`, удаляем элемент с этим номером. remove_negative является примером совместного использования предыдущих предикатов.

Примеры использования:
```prolog
?- first_negative(X,[1,2,-3,4,5]).
X = 3.
?- first_negative1(X,[1,-2,-3,4,-5]).
X = 2 .
?- remove_negative([1,2,-3,4,-5],X).
X = [1, 2, 4, -5].
```

Реализация:
```prolog
% без применения стандарных предикатов
first_negative(1,[Y|_]):- 
    Y < 0, !.
first_negative(N,[_|X]):- 
    first_negative(N1,X),
    N is N1 + 1.

% с применением стандарных предикатов
first_negative1(1,[Y|_]):- 
    Y < 0.
first_negative1(N,[Y|T]):-
    Y >= 0,
    length(T,K),
    K > 0,
    first_negative1(N1, T),
    N is N1 + 1.

% пример совместного использования предикатов
remove_negative(L,L1):-
    first_negative(N,L),
    remove_n(N,L,L1).
```


## Задание 2: Реляционное представление данных

Реляционное представление данных основано на интуитивно понятном, доступном табличном способе. Поэтому к достоинствам реляционного представления можно отнести простоту и независимость данных дргу от друга. Среди недостотков присутствует большой расход памяти, по сравнению с другими представлениями данных.

В моем варианте используется представление `two.pl`, факты такого реляционного представления имеют формат: `grade(Group,Subject,Student,Mark)`. Это представление удобно тем, что можно легко получить при помощи стандартного предиката `findall` список группы, или же найти в какой группе учится студент. К минусам можно отнести множественное повторение имен студентов из-за чего представление занимает больше места по сравнению с другими, и в случае измнения, придется менять не одну строчку, например, если бы студент захотел поменять имя.

`mark(Student,X)` - находит средний балл для студента, и проверяет сдал ли он все экзамены или нет. Предикат `check` принимает список из оценок студента и проверяет на то, чтобы среди оценок не было 2, если студент сдал все экзамены, его статус равен 1, иначе - 2. Предикат `get_marks` считает средний балл студента при помощи предикатов `sum` и `length`. Предикат `mark` выводит фамилию студента, его средний балл и статус сдачи экзаменов.

Примеры использования:
```prolog
?- mark('Петров',X).
X = ['Петров', 3.8333333333333335, 'dont pass exams'].
?- mark('Иванов',X).
X = ['Иванов', 3.8333333333333335, 'pass exams'].
?- mark('Программиро',X).
X = ['Программиро', 4.333333333333333, 'pass exams'].
```

Реализация:
```prolog
sum([],0).
sum([H|T],X):-
    sum(T,X1),
    X is X1 + H.

check([2|_],2):-!.
check([],1):-!.
check([_|T],Status):-
    check(T,Status).

get_marks(Student,Mark,Status):-                        
    findall(Mrk,grade(_,Student,_,Mrk),Marks),
    sum(Marks,N),
    check(Marks,Status),
    length(Marks,Len),
    Mark is N / Len.

mark(Student,[Student,Mark,Message]):-
    get_marks(Student,Mark,Status),
    Status = 2,
    Message = 'dont pass exams',
    !;
    get_marks(Student,Mark,Status),
    Message = 'pass exams',!.
```

`dont_passed(Subject,Count)` - для каждого предмета находит количество не сдавших студентов. Предикат `setof` выведет список из студентов из разных групп, у которых оценка по экзамену равна 2. Стандратный предикат `length` посчитает длину этого списка.

Примеры использования:
```prolog
?- dont_passed(S,X).
S = 'Английский язык',
X = 4 ;
S = 'Информатика',
X = 2 ;
S = 'Логическое программирование',
X = 2 ;
S = 'Математический анализ',
X = 3 ;
S = 'Психология',
X = 1 ;
S = 'Функциональное программирование',
X = 1.
```

Реализация:
```prolog
dont_passed(Subject,Count):-
    setof(Student,A^grade(A,Student,Subject,2),S),
    length(S,Count).
```

`students_with_max(Group,List)` - для каждой группы находит студента (студентов) с максимальным средним баллом. Предикат `get_list_marks` создает список из средних оценок студентов. Предикат `calc_max_mark` находит максимальную оценку среди списка средних оценок. Предикат `max_mark` находит максимальную среднюю оценку в заданной группе. Конечный предикат `students_with_max` сравнивает среднюю оценку каждого студента с максимальной средней оценкой его группы.

Примеры использования:
```prolog
?- students_with_max(101,X).
X = ['Густобуквенникова'].
?- students_with_max(102,X).   
X = ['Текстописов'].
?- students_with_max(103,X).
X = ['Вебсервисов', 'Клавиатурникова', 'Программиро'].
?- students_with_max(104,X).
X = ['Круглосчиталкин'].
```

Реализация:
```prolog
get_list_marks([],[]):-!.
get_list_marks([Students|S],[Max|M]):-
    findall(Mrk,grade(_,Students,_,Mrk),Marks),
    sum(Marks,N),
    length(Marks,Len),
    Max is N / Len,
    get_list_marks(S,M).
	
calc_max_mark([],Current_Max,Max):-
    Max is Current_Max,!.
calc_max_mark([Marks|M],Current_Max,Max):-
    Marks > Current_Max,
    calc_max_mark(M,Marks,Max),!;
    calc_max_mark(M,Current_Max,Max),!.

max_mark(Group,Max):-
    findall(Student,grade(Group,Student,_,_),S),
    get_list_marks(S,Marks),
    calc_max_mark(Marks,0,Max).

students_with_max(Group,List):-
    max_mark(Group,Max),    
    setof(Student,(grade(Group,Student,_,_),get_marks(Student,Mark),Mark==Max),List),!. 
```

## Выводы

Выполнив свою первую лабораторную работу я научилась работать со стандартыми предикатами, писать собственные, а также обрабывать списки. Во время написания лабораторной я познакомилась со средством отладки `trace`, оно позволяет пошагово смотреть, какие правила программа применяет, так свои ошибки можно находить быстрее. Сами задания были достаточно простые, сложность оказывалась в реализации, ведь работая с Prolog надо думать на несколько шагов вперед. Реализуя программу со стандартными предикатами и без их использования, у меня получались 2 абсолютно разные идеи решения одного задания, было сложно отстраниться от прошлой идеи решения, чтобы придумать что-то новое.  

Основным методом обработки оказалась рекурсия, так как списки в Prolog являются рекурсивной структурой, возможно, это не самый эффективный способ, но ведь быстрая обработка не является главной целью языка. Осбенность Prolog заключается в том, что его легко читать, но очень сложно писать. Prolog заставляет думать по-другому, мне было достаточно сложно переключиться на декларативный язык. Теперь мы должны описывать не процедуру решения задачи, а логическую модель: некоторые факты и правила.
