# Реферат
## по курсу "Логическое программирование"

### студент: Шевлякова С. С.

## Как научить младшего брата логическому программированию?

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение
Какого ребёнка можно обучить логическому программированию и возможно ли это вообще? Конечно, ученику начальных классов объяснить любое программирование будет достаточно сложной задачей, тем более мне, человеку не имеющего преподавательского опыта. Поэтому давайте внесем больше конкретики, пусть мой младший брат учится в средней школе, потому что для обучения логическому программированию ребенок должен иметь хоть какое-то представление о компьютерах, математике и логике. 

В этот эссе я бы хотела поговорить о том, как простыми словами мы можем донести до ребенка достаточно сложные вещи, какие сравнения и ассоциации могут помочь нам в этом, а также с какими трудностями можно столкнуться в процессе обучения. Наверное, очень необычно начинать знакомство ребенка с миром программирования и современных технологий именно с логического программирования. Анализируя свой опыт, полученный в рамках этого курса,  могу сказать, что логическое программирование мне было достаточно тяжело освоить, потому что это совершенно другие понятия, идеи и подход к программированию, задействована часть курса дискретной математики. Но ребенок, который не познал еще в полной мере процедурного программирования, может с легкостью воспринимать логическое, как самый первый язык. 

## Основные принципы обучения логическому программированию
Не представляю, что ребенка может заинтересовать серьезная теория, которая относится к логическому программирования, поэтому во время обучения стоит особое внимание уделить практике, такой подход не будет мучительным для ребенка. Стоит показать возможности языка на реальных задачах. Когда младший брат увидит, что компьютер способен буквально моментально решать задачу, на которую у него может уйти больше 10 минут, это сможет его вдохновить и вызвать интерес.

Я не имела опыта работа с языком логического программирования Mercury, поэтому во время обучение будем использовать Prolog, к этому языку у меня претензий нет, и особых проблем в работе не возникало, единственный его минус – небольшая производительность, но в процессе обучения это не имеет значения. Как говорится в книге У. Клоксина «Программирование на языке ПРОЛОГ»: Prolog является одним из первых шагов на пути к главной цели: программированию на языке логики. Знакомство с Prolog нельзя начинать  так же, как и с другими языками, мы не можем сразу начать писать “Hello world!” или решать арифметические задачи, это не будет иметь смысла. Так как главное отличие логических языков программирования заключается в том, что мы не говорим компьютеру, как делать, а говорим, каких целей хотим достичь, все остальное программа решает сама. 

Итак, главные правила обучения ребенка логическому программированию:
- Переходим от абстрактных понятий к конкретным.
- Стараемся приводить как можно больше примеров из реальной жизни, обучение должно быть игрой, а не наказанием для ребенка.
- Не используем сложные определение, стараемся говорить простыми, понятными ребенку словами.
- Не углубляемся в теорию математической логики, а решаем конкретные логические задачи.
- Учитываем собственные трудности при освоении курса логического программирования.
- Показываем ребенку, что программирование – это возможность придумать что-то новое и импровизировать.

## Логическое программирование
Разобравшись с основными принципами нашего обучение, мы наконец то можем начинать. Сначала мы должны дать ребенку представления о программировании. Программирование – это процесс написание программ. Программа – это набор неких правил или точнее инструкций. Акцент надо сделать на том, что компьютер является машиной, он не понимает русского, английского и других языков, но он отлично понимает языки программирования. Задача программиста заключается в том, что с помощью языка программирования мы смогли объяснить машине, что вообще хотим от нее. 

Думаю, что рассказ о разных парадигмах программирования не очень заинтересует ребенка, поэтому лучше не углубляться в эту тему. Достаточно сказать, что логическое программирование, не трудно догадаться, основывается на логике. Объяснить определение логики, как философской дисциплины, будет сложно, поэтому стоить сказать, что логика – это наука о рассуждениях, и одна из ее главных задач – получить истинное знание о предмете, над которых мы рассуждаем, или сделать истинный вывод из суждений или предложений. Теперь мы можем сложить эти два новых (или не очень) понятия: логическое программирование – написание программ на основе логики, с помощью которых компьютер может решить задачу, поставленную человеком. 

## Как устроена программа?
Правила в логическом программировании — это совсем не правила русского языка в школе, очень расплывчатые и длинные, правила в логическом программировании совсем другие – четкие и короткие. Это даже больше не правила, а инструкции: «если так, то делай вот это, а потом делай это» (как мама, которая раздает вам с братом задания во время субботней уборки). Как мы уже говорили, компьютер может понимать только инструкции, эти инструкции в Prolog называются предикатами. Также в программе могут использоваться факты – это утверждения, которые мы можем выделить из условий задачи (например, когда мы записываем «Дано» при решении задачи по физике). Последний этап в написании программы: формулировка запросов. Запросы – это вопросы, которые ты можешь задавать программе, а она в ответ сможет дать ответ, на основании написанной программы.

Итак, программа состоит из следующих компонентов:
1.	факты
2.	предикаты
3.	запросы

Самое главное понять ребенку – предикат показывает отношение. Рассмотрим самый простой: sibling(sofia, sasha), из этого предиката мы можем узнать, что София – это сестра Саши. Лучше всего будет  показывать это на примере своей семьи, так для ребенка это будут не просто чьи-то имена, а конкретные люди, которых он хорошо знает. Предикат не являемся односторонним отношением, так как мы знаем, что София является сестрой для Саши, а значит Саша – это брат Софии. Такие примеры стоит рассмотреть и с другими родственниками: с мамой и папой, бабушками и дедушками, чем больше вы разберете с ребенком примеров из реально жизни – тем лучше. 

## Первая программа
Конечно, что-то вроде первой программы мы можем написать прямо в терминале без использования предикатов и фактов:
```prolog
?- X is 2 + 3.
X = 5.
```
Но какой в этом смысл, если главное отличие логического программирования от императивного в том, что оно задает отношение между объектами. Давайте напишем нашу настоящую программу: сначала на основании фактов. Обратите внимание ребенка на синтаксис языка: каждый факт должен начинаться с новой строчки и заканчиваться точкой.
```prolog
sibling(sofia, sasha).
mother(svetlana, sasha).
mother(svetlana, sofia).
```
Теперь наша задача показать примеры запросов, которые можно сделать на основании фактов. Полагается, что мой младший брат знает такое понятие, как переменная и работал в школе с решением уравнение. Рассмотрим запросы:
```prolog
?- sibling(sofia, svetlana).
false.

?- sibling(X, sasha).
X = sofia.

?- sibling(sofia, X).
X = sasha.

?- mother(X, sasha).
X = svetlana.

?- mother(svetlana, X).
X = sasha ;
X = sofia.
```
Чтобы получить всевозможные решения после вывода одного ответа можно нажать ```;```. С помощью запроса мы можем или проверить существование какого-то факта, либо найти неизвестное значение. Так как такого факта, как ```sibling(sofia, svetlana)``` среди наших фактов не существует, то компьютер возвращает ```false```. Когда запрос содержит переменную X (название не имеет значение, но лучше давать осмысленные имена), то мы говорим компьютеру, что ищем именно это значение, можем перевести запрос ```sibling(X, sasha)``` на обычный язык: «Какой X будет являться сестрой/братом для Саши?» 

Запрос работает так: компьютер читает вашу строчку и начинает искать похожу строчку среди фактов, сначала он смотрит совпадению по названию предиката. В нашем случае среди фактов есть только один с названием sibling, здесь компьютер остановится и сопоставит каждый аргумент. Если X = sofia, то факт является верным, компьютер нашел значение переменной, при которой факт становится верным, именно это значение он и выведет. С остальными запросами попробуйте проделать эту же работу вместе с ребенком. Хочется сделать небольшое замечание по синтаксису: переменная в Prolog пишется с большой буквы, в отличие от других элементов.

Но наибольший интерес вызывает запрос ```mother(svetlana, X)```, так как он имеет два решения. Сначала компьютер натыкается на факт ```mother(svetlana, sasha)```, отсюда X = sasha, но на этом он не останавливается, продолжает поиск дальше и встречает факт ```mother(svetlana, sofia)```, отсюда компьютер найдет второе решение X = sofia.

Теперь можем написать программу посложнее, которая будет включать в себя не только факты, но и предикат:
```prolog
sibling(sofia, sasha).
mother(svetlana, sasha).
mother(X, Y) :- mother(X, Z), sibling(Y, Z).
```
Предикат ```mother(X, Y)```, который говорит, что X является матерью Y, если выполняются 2 условия одновременно: X являются матерью для еще одного ребенка Z, Y и Z являются братьями/сестрами. Это логично, поскольку, если мать имеет двоих детей, то они между собой являются братьями/сестрами. Разберемся с синтаксисом: символ ```:-``` обозначает, что дальше идет условие предиката. Запятая между двумя правилами говорит нам о том, что оба эти правила должны являться верными одновременно, если хотя бы одно из правил не выполняется, то предикат не сработает. Если между двумя правилами стоит точка с запятой, то это значит, что хотя бы одно из правил должно быть верным, только если оба правила одновременно являются неверным, то предикат не сработает. Запрос к этой программе может выглядеть так:
```prolog
?- mother(X, Y).
X = svetlana,
Y = sasha;
X = svetlana,
Y = sofia.
```
Мы убедились, что наш предикат работает верно. Советую предложить ребенку решить простую задачу. У нас есть факты:
```prolog
older(sofia, sasha).              %% София старше Саши
older(oleg, sofia).               %% Олег старше Софии
older(sasha, nastya).             %% Саша старше Насти
```
Если что, при поомщи занка ```%%``` мы можем оставлять комментарии - это текст или код, который будет игнорировать комьютер, обычно программисты сотавляют комментарии, чтобы делать пометки.
Вам надо вместе с ребенком написать предикат, который для X и Y из нашего множества фактов сможет определить, кто из них старше. Этот предикат должен выглядеть так:
```prolog
older(X, Y) :- older(X, Z), older(Z, Y).
```
То есть X старше Y, если X старше Z, и Z старше Y. На языке математики это можно написать так: X > Y :- X > Z, Z > Y. Попробуйте написать разные запросы к этому предикату.

Если вы видите, что ребенок не испытывает трудности с пониманием, то дополнительно можно рассказать про анонимную переменную ```_```. Переменная называется анонимной, потому что нам не важно, какое значение будет на ее месте, такая переменная может быть любой.

## Список и рекурсия
Приготовьтесь, этот раздел будет достаточно сложным, такие темы обычно проходят студенты, но почему бы не попробовать объяснить это школьнику, ведь не все так уж и сложно. 

Список – это упорядоченная последовательность элементов произвольной длинны, но не думаю, что такое определение понравится ребенку. Как по мне, самое лучшее сравнение для списка – это стопка книг: мы знаем, какая книга лежит у нас в самом начале, знаем сколько книг лежит стопке, но не знаем, что за книги лежат после первой. Первая книга называется головой списка, а все остальные книги в стопке – хвостом. Но как же посмотреть, что лежит в хвосте? Для этого просто удалим голову списка и увидим следующий за ней элемент, в случае нашего примера: уберем из стопки верхнюю книгу и сможем увидеть, какая книга лежит за ней, при этом длина списка уменьшается на 1. Убирая голову списка каждый раз, мы сможем просмотреть все элементы списка. 

На примере книги мы рассмотрели такую структуру как список, я бы хотела еще раз сделать акцент на двух вещях: у списка есть голова ```Head``` и хвост ```Tail```, и мы знаем только то, что лежит в голове списка. Также стоит обратить внимание, что стопка, в которой нет ни одной книги, является списком, поэтому пустой список – это тоже список. Ну и немного синтаксиса: список с двух сторон оборачивается квадратными скобками ```[]```. Внутри списка могут находиться любые элементы: буквы, цифры, символы или другие списки, примеры списков: ```[a, b, c, d]```, ```[4, 50, 100, 0, -20]```, ```[[a,b],[c,r,t],[a]]``` (в качестве проверки понимания темы я бы спросила младшего брата, сколько элементов содержится в последнем списке).

Мой младший брат имеет уже достаточно знаний, чтобы понять работу предиката для перебора всех элементов списка:
```prolog
list([Head|Tail], Element) :- Element = Head; list(Tail, Element).
```
Разберемся, как работает этот предикат. ```list([Head|Tail],Element)``` будет истинным, если Element равен Head (первому элементу списка) или если предикат ```list(Tail, Element)``` истинный. Переменная Element будет принимать значения элементов списка. Список мы разделяем на голову Head и хвост Tail, как мы уже знаем, в Head лежит один элемент, а вся остальная часть списка лежит в Tail. Сначала сравниваем Element и Head. Вообще, на этом моменте мне хочется сделать одну очень плохую вещь: сказать младшему брату, что здесь происходит присваивание переменной Element значения Head, так как операцию унификации на данном этапе будет достаточно сложно понять, так мы только запутаем ребенка.  Prolog вообще не имеет оператора присваивания, существует только операция унификация, в ходе которой происходит сопоставление левой и правой части и в случае удачного сопоставления конкретизация неизвестных значений. Вернемся к нашему предикату: сначала он выведет Head, а дальше рекурсивно запустит эту же функцию, но уже от хвоста. 

Кажется, что понятия рекурсии нам не избежать, так как оно будет использоваться дальше при написании стандартных предикатов. Для своего младшего брата я бы сказала, что рекурсия – это ситуация, в которой объект является частью самого себя. Самым простым примером здесь будет матрешка. Возможно, потребуется время, чтобы понять это, надо запостись терпением и идти до конца, если уж взялись за такую сложную задачу. В случае с Prolog, когда мы говорим, что предикат вызывается рекурсивно – это значит, что предикат вызывается внутри самого себя, но уже с иными аргументами. В нашей задаче предикат list вызывается рекурсивно от хвоста списка, потому что мы уже вывели первый элемент, его можно убрать, и теперь надо смотреть следующий элемент, но конкретно второй элемент нам не известен.

Так Prolog выведет все решения, и мы сможем перебрать все элементы списка. Запрос к предикату может выглядеть так:
```prolog
?- list([1,2,3,4],X).
X = 1 ;
X = 2 ;
X = 3 ;
X = 4 ;
false.
```
Мы объяснили ребенку, что такое список, и что такое предикат, теперь можем перейти к изучению стандартных предикатов.

## Стандартные предикаты
Изучение стандартных предикатов является важной частью обучения логическому программированию, потому что они часто используются при решении задач, и чтобы не возникало вопросов в дальнейшем, хотелось бы хорошо разобраться сейчас. Особое внимание стоит уделить примерам. Я бы предложила своему брату поиграть с предикатами, придумать свои примеры, благодаря им можно проверять себя.

Предикат ```length(L,N)``` находит длину N списка L. При написании стандартных предикатов необходимо рассматривать крайние случаи, поэтому важно прописать, что длина пустого списка равна 0, также это условие используется для остановки рекурсии. Для нахождения длины списка ненулевой длины будем рекурсивно вызывать предикат ```length``` от хвоста списка, длина этого списка будет уже на 1 меньше, так как мы убрали из него голову, это будет продолжаться до тех пор, пока не останется пустой список.
```prolog
length([],0).
length([_|T],N):-
    length(T,N1),
    N1 is N - 1.

?- length([],X).
X = 0.
?- length([1,2,a,b,1],X).
X = 5.
```

Предикат ```member(X,L)``` проверяет принадлежность переменной X к списку L. Рассмотрим 2 случая: если переменная X является головой списка, то очевидно, что она принадлежит списку, и если переменная X не является головой списка, то может быть она принадлежит хвосту списка, поэтому рекурсивно проверяем это условие.
```prolog
memeber(H,[H|_]).
memeber(X, [_|T]):-
    memeber(X,T).
    
?- member(1,[2,3,1,4]).
true
?- member(b,[a,a,c,d,bb]).
false.
```

Предикат ```append(L,L1,R)``` реализует склеивание списков L и L1, получая список R. Сначала рассматриваем крайний случай: если пустой список сложить со списком X, то получим X (по правилу 0 + Х = Х). Если мы складываем список [H|T] и L, то сумма этих списков будет иметь начало первого, то есть голова первого списка и конечного будет совпадать. Задача состоит в том, чтобы выяснить, как соединить хвост первого списка со вторым, для этого рекурсивно вызываем предикат ```append``` уже от хвоста первого списка.
```prolog
append([],X,X).
append([H|T],L,[H|R]):-
    append(T,L,R).
    
?- append([1,2],[3,4],X).
X = [1, 2, 3, 4].
?- append(X,[3,4],[1,2,3,4]).
X = [1, 2] ;
```

Предикат ```remove(X,L,R)``` удаляет элемент X из списка L, получая список R. И снова рассматриваем два случая: если элемент, который мы хотим удалить является головой списка, то в результате мы получим только хвост. Если же нам необходимо удалить элемент, который лежит не в голове списка, то рекурсивно будем вызывать предикат ```remove``` от хвоста этого списка, так, перебирая весь список, мы сможем дойти до того момента, когда в голове списка будет лежать нужный нам элемент, а это первый случай, который мы рассмотрели выше.
```prolog
remove(H,[H|T],T).
remove(X,[H|T],[H|T1]):-
    remove(X,T,T1).
    
?- remove(a,[b,c,a,d],X).
X = [b, c, d] ;
?- remove(X,[b,c,a,n],[b,c,n]).
X = a ;
```

Предикат ```permute(L,L1)``` cоставляет всевозможные перестановки списка L и ответ записывается в L1. Как обычно рассмотрим два случая: если всевозможными способами пытаться переставлять пустой список, мы все равно получим пустой список, так как, по сути, переставлять нам и ничего, никаких элементов пустой список не содержит. Если же мы имеем непустой список, то начнем проверять перестановки с конца, то есть удалим голову списка и рекурсивно вызовем предикат ```permute``` от хвоста, так будет продолжаться, пока у нас не останется пустой список.
```prolog
permute([],[]).
permute(L,[H|T]):-
    remove(H,L,R),
    permute(R,T).
    
?- permute([a,b,c],X).
X = [a, b, c] ;
X = [a, c, b] ;
X = [b, a, c] ;
X = [b, c, a] ;
X = [c, a, b] ;
X = [c, b, a] ;
```

Предикат ```sublist(S,L)``` проверяет является ли S подсписком L, то есть является ли список S частью списка L. В этом нам помогает уже изученный стандартный предикат ```sublist```: если к списку S прибавить какой-то другой список, то мы получим промежуточный список L1. Если какой-то список добавить к L1, то мы получим наш конечный список L, такое условие удовлетворяет всем случаям: если предикат S находится в начале, середине и конце списка.
```prolog
sublist(S,L):-
  append(_,L1,L),
  append(S,_,L1).
    
?- sublist([1,2,3],[2,3,1,2,3,4]).
true .
?- sublist([2,3],[3,2,1,4]).
false.
```

## Логическая задача
Во время изучения курса логического программирования, одна из лабораторных работ заключалась в решении логической задачи на языке Prolog. Эти задачи очень напомнили мне те, что мы решали в начальной школе для развития логики. Поэтому завершим обучение моего младшего брата решением одной из таких задач. Может быть решение задачи при помощи логического программирования не всегда является оптимальным способом, но это очень важный этап в обучении.

*В автомобильных гонках три первых места заняли Алеша, Петя и Коля. Какое место занял каждый из них, если Петя занял не второе и не третье место, а Коля - не третье?*
Если бы эту задачу мой брат решал в школе на уроке математики, то он обязательно решал бы ее построением таблицы. В качестве эксперимента я бы дала брату задание решить эту задачу на листочке, после написания программы на Prolog он сможет проверить себя. Ведь человек может ошибаться, а машина – никогда. 

Для решения этой задачи будем использовать 2 стандартных предиката ```remove``` и ```permute```, чтобы составить всевозможные перестановки списка [1,2,3]. Предикат ```do_task``` составляем всевозможные перестановки [1,2,2], которые удовлетворяют условиям задачи ```Petya =\= 2, Petya =\= 3,``` - Петя занял не второе и не третье место, ```Kolya =\= 3```  Коля - не третье. Символ ```=\=``` является противоположным по назначения для символа ```=```. Теперь задача компьютера состоит в том, чтобы составить всевозможные перестановки, удовлетворяющим этим трем условиям, так мы получим единственный верный ответ.
```prolog
remove(H,[H|T],T).
remove(X,[H|T],[H|T1]):-
    remove(X,T,T1).

permute([],[]).
permute(L,[H|T]):-
    remove(H,L,R),
    permute(R,T).

do_task(Alesha, Petya, Kolya):-
    permute([Alesha, Petya, Kolya], [1,2,3]),
    Petya =\= 2, Petya =\= 3, Kolya =\= 3.
    
?- do_task(Alesha, Petya, Kolya).
Alesha = 3,
Petya = 1,
Kolya = 2
```
Мне кажется, что на этом наше введение в логическое программирование можно закончить! Но если ребенок еще полон энтузиазма, и просит вас рассказать еще что-нибудь, то я бы предложила ему рассмотреть тему бинарных деревьев и порешать другие логические задачи, которых в сети есть огромное количество. В конце курса мне бы хотелось сказать своего младшему брату одну важную вещь: программа, как пластилин, ты можешь сделать из неё любую вещь, в независимости от языка программирования.

## Заключение
Подводя итог, я могу сказать, что у меня получился небольшой вводный курс, который подойдет не только детям, но и взрослым, которые до этого не имели опыта программирования. Мы заложили очень неплохой фундамент для дальнейшего изучения программирования: узнали, что вообще такое программирование и как это работает, познакомились с такой структурой, как список, а также узнали о логическом И и логическом ИЛИ. Когда ты можешь объяснить тему другому человеку, а уж тем более маленькому ребенку, то можно смело заявлять, что ты усвоил материал. Также большую роль играет твоя личная заинтересованность в предмете, если ты сможешь передать весь свой энтузиазм ребенку, то изучение логического программирования окажется для него затягивающей игрой.

Логическое программирование очень отличается от императивных языков, поэтому мне было бы очень интересно узнать опыт своего младшего брата в изучение императивных языков после декларативных, так как обратный я уже испытала на себя (и было это не очень просто). Работая над этим эссе, к моему удивлению, я неплохо подготовилась к зачету, потому что разобрала еще раз стандартные предикаты и порешала логические задачи. 

## Список используемых источников
1.	У. Клоксин, К.Меллиш, Программирование на языке Пролог.
2.	Д. В. Сошников. Парадигма логического программирования.
3.	Введение в логическое программирование (Prolog) https://pro-prof.com/archives/2362
4.	Prolog, введение. https://habr.com/ru/post/49399/
5.	Решение логических задач. http://uneex.ru/static/AltDocs_informatika2/Book2/ch_10_prolog/09_logik_task/index.html
