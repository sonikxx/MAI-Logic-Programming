# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: <Шевлякова София Сергеевна>

## Результат проверки

Вариант задания:

 - [x] стандартный, без NLP (на 3)
 - [ ] стандартный, с NLP (на 3-4)
 - [ ] продвинутый (на 3-5)
 
| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение
В ходе выполнения этой лабораторной работы я напишу свой первый парсер на Python, углублю свои знания в логическом программировании, а также применю те знания, которые уже получила при выполнении лабораторных работ, теперь я смогу учесть все свои ошибки и написать более качественный код. Ну и обработка генеалогического дерева — это, наверное, лучший вариант показать студентам, как мы можем использовать логическое программирование в реальной жизни.

## Задание
1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM. Если Вы по каким-то причинам не хотите использовать свою родословную - вы можете использовать файл родословной европейской знати.
2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog с использованием предикатов ```father(отец, потомок)``` и ```mother(мать, потомок)```.
3. Реализовать предикат проверки/поиска шурина.
4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве, например:

## Получение родословного дерева
Для своей курсовой работы я использовала родословную английского поэта и драматурга Уильяма Шекспира, в формате GEDCOM я нашла ее на сайте: https://webtreeprint.com/tp_famous_gedcoms.php Это родословное дерево содержит 24 человека.

## Конвертация родословного дерева
Для преобразования файла в формате GEDCOM в набор утверждений на языке Prolog я использовала язык Python, потому что в нем существует специальная библиотека для парсинга GETCOM файлов ```ged4py.parser```. Доя этого я использовала GedcomReader: в файл my_kp.pl для каждого человека из файла shakespeare.ged записывается его мать в формате ```mother(мать, человек)```, а потом отец ```father(отец, человек)```, каждое с новой строчки
```python
import sys
from ged4py.parser import GedcomReader

path = "shakespeare.ged"
file = open('my_kp.pl', 'w')
parser = GedcomReader(path)

with GedcomReader(path, encoding="utf-8") as parser:
    for n, human in enumerate(parser.records0("INDI")):
        mother = human.mother
        if mother:
            file.write("mother('" + mother.name.format() + "','" + human.name.format() + "'). \n")
    for n, human in enumerate(parser.records0("INDI")):
        father = human.father
        if father:
            file.write("father('" + father.name.format() + "','" + human.name.format() + "'). \n")
file.close()
```

## Предикат поиска родственника
В моем варианте надо было реализовать предикат поиска шурина, шурин - это брат жены, для этого сначала найдем жену этого мужчины, а потом ее брата, в ходе реализации я использовала дополнительные предикаты ```married(Wife,Husband)``` и ```brother(Brother,X)```:
```prolog
brother(Brother, Y) :-
    father(Brother, _),
    mother(Mom, Brother),
    father(Dad, Brother), 
    mother(Mom, Y),
    father(Dad, Y),
    Brother \= Y.
    
married(Wife, Husband) :-
    mother(Wife, Child),
    father(Husband, Child).

brotherInLaw(X, Husband) :-
    married(Wife, Husband),
    brother(X, Wife).
```
Но мое представление данных имеет несколько значительных минусов: если у человека нет детей, то невозможно определить его пол (но эта проблема решаема: в случае отсутствия ребенка можно писать просто null), помимо этого, единственная возможность определить то, что люди были женаты, это наличие общего ребенка.

Пример запроса, отсюда мы узнали, что в этой родослновной Шекспира есть только один шурин ```Hamnet Shakespeare```:
```prolog
?- brotherInLaw(X,Y).          
X = 'Hamnet Shakespeare',
Y = 'John Hall' ;
X = 'Hamnet Shakespeare',
Y = 'Thomas Quiney' ;
```

## Определение степени родства
Чтобы реализовать поиск родственников необходимо объявить несколько описаний родства. Ниже я привела несколько примеров отношений, не думаю, что здесь требуются какие-то дополнительные пояснение, так как в случае моего представления данных это реализуется достаточно просто, в приложенном файле kp.pl вы сможете найти полный список реализованных предикатов:
```prolog
sibling(X, Y) :-
    mother(Mom, X),
    father(Dad, X), 
    mother(Mom, Y),
    father(Dad, Y),
    X \= Y.

% золовка - сестра мужа
sisterInLaw(X, Wife) :-
    married(Wife, Husband),
    sister(X, Husband).

% тёща - мать жены
tesha(X, Husband) :-
    married(Wife, Husband),
    mother(X, Wife).

% свекровь - мать мужа
svekrov(X, Wife) :-
    married(Wife, Husband),
    mother(X, Husband).
    
daugther(Daugther, Mom) :-
    mother(Daugther, _),
    mother(Mom, Daugther).

daugther(Daugther, Dad) :-
    mother(Daugther, _),
    father(Dad, Daugther).

grandma(Grandma, X) :-
    mother(Mom, X),
    mother(Grandma, Mom),
    father(Dad, X),
    mother(Grandma, Dad).

grandson(Grandson, X) :-
    father(Grandson, _),
    grandma(X, Grandson).

grandson(Grandson, X) :-
    father(Grandson, _),
    grandad(X, Grandson).
```

Для определения звязей между двумя людьми я решила использовать итеративный поиск, который уже реализовывала в одной из лаборатрной. Алгоритм с итеративным погружением совмещает в себе признаки и алгоритма поиска в ширину, и алгоритма поиска в глубину. Так как он, с одной стороны, рекурсивен и опускается вглубь а, с другой стороны, он находит варианты ответа от меньшего к большему. При самом поиске решений, мы проверяем, что количество оставшихся шагов больше нуля, и если это так, то мы продлеваем пройденный путь, уменьшаем количество оставшихся шагов и пытаемся найти путь из следующего состояния. Параметр N1 ограничивает глубину поиска, если на этом уровне глубины не найдется ни одно решение, то N будет увеличено в цикле.
```prolog
int(1).
int(N1) :-
	int(N),
	N1 is N+1.

search([Now|T1], Now, [Now|T1], [], 1). 
search([Now|T1], Final, Way, [Result|T2], N) :-
	N > 0,
	move(Now, New, Result),
	not(member(New, [Now|T1])),
	M is N-1,
	search([New, Now|T1], Final, Way, T2, M).

iter_search(Start, Final, Way, Result) :-
	int(N1),
	(N1 > 100, !;
	search([Start], Final, Way, Result, N1)).

% Определение степени родства
relatives(X, Y, Result):-
	iter_search(X, Y, _, Result).
```
Если человек не имеет указанного родственника, то программа возвращает true. 

Пример работы программы:
```prolog
?- relatives('Richard Shakespeare','John Shakespeare',X).
X = [father].

?- relatives(X,Y,[tesha]).  
X = 'Agnes Webbe',
Y = 'John Shakespeare'.

?- relatives(X,'Joan Shakespeare',[brother]).
X = 'Richard Shakespeare' ;
X = 'William Shakespeare' ;

?- relatives(X,'Joan Shakespeare',[sister]). 
true.
```

## Выводы
В ходе работы над этим курсовым проектом я написала реферат на тему: "Как научить младшего брата логическому программированию?", а также программу на языке Prolog, которая устанавливает родственные отношения между двумя индивидуумами родословного дерева. Я вспоминаю свою первую лабораторную работу, как долго и мучительно я привыкала к новой парадигме, к логическому программированию и, в частности, к Prolog, и как сейчас, мне не составляет особого труда написать предикаты, реализовать поиск с итеративным погружением, а также решить логичскую задачу. Меньше всего я ожидала в курсе логического программирования расширить свои знания в Python, я впервые писала парсер. 

Этот курсовой проект оказался одним из немногих, которые мне действительно понравилось выполнять. В конце изучения предмета я могу сделать вывод: логическому программированию уделяется слишком мало внимания, несмотря на большое количество плюсов (чего только стоит возможность работы с большим объемом данных), многие не относятся к нему серьезно. Я научилась смотреть на задачу под другим углом, применять разные подходы, и я уверена, что полученные навыки обязательно пригодятся мне в дальнейшем обучении.
