#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студентка: Шевлякова С. С. 

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение
Существует несколько подходов к решению логических задач. Одним из них является метод перебора: формируется множество всевозможных вариантов и каждый проверяется в соответствии с условиями задачи, в случае противоречия - выполняется возврат и проверяется следующий вариант. То есть решение задачи сводится к написанию критериев, по которым мы будем находить неправильные варианты решения, для этого необходимо условия задачи превратить в некоторые логические правила, предикаты. Используя этот метод, можно быть уверенным, что ни одно решение случайно не потеряется, а отсутствие решения будет доказано. Главный минус метода - неэффективность, требуются большие затраты по времени. Второй метод решения логических задач основан на предварительном анализе условий задачи и отсеивании целых подмножеств решений, что позволяет генерировать меньше возможных вариантов. Благодаря этого второй способ является более эффективным по сравнению с первым. Помимо этого, также существуют и иные методы решения логических задач: построение таблиц истинности, использование законов алгебры логики, создание дерева решений.

Prolog оказывается очень удобным для написания решателей логических задач, потому что достаточно просто описать условия задачи сначала в виде логических выражений, а потом при помощи средств Prolog в виде предикатов. Также в случае нахождения неправильного варианта Prolog выполняет возврат и продолжает поиск с предыдущего шага.

## Задание

Воронов, Павлов, Левицкий и Сахаров четыре талантливых молодых человека. Один из них танцор, другой художник, третий певец, четвертый писатель. Воронов и Левицкий сидели в зале консерватории в тот вечер, когда певец дебютировал в сольном концерте. Павлов и писатель вместе позировали художнику. Писатель написал биографическую повесть о Сахарове и собирается написать о Воронове. Воронов никогда не слышал о Левицком. Кто чем занимается?

## Принцип решения
Это задача решается методом перебора всевозможных решений и проверкой каждого на непротиворечивость условиям. Используя стандартный предикат `permute(L,L1)` мы можем инициализировать список, в которым в соответствие каждой профессии поставлена фамилия. Далее список проверяется на непротиворечивость условиям, в случае возникновения противоречия, предикат `permute(L,L1)` создает иную перестановку, и так далее, пока мы не найдем верный ответ. Такое решение является достаточно эффективным, благодаря изначальной инициализации мы оптимизируем решение, уменьшая количество переборов. Также решение будет безопасным, так как мы гарантированно знаем, что задача имеет ровно один ответ, и зацикливания и комбинаторного взрыва в такой реализации быть не может.

Условие задачи содержит 4 пункта, каждый из которых мы сможем записать в виде логического выражения:
1. "Воронов и Левицкий сидели в зале консерватории в тот вечер, когда певец дебютировал в сольном концерте" - это значит, что ни Воронов, ни Левицкий не являются певцами `Singer \= voronov, Singer \= levitsky`
2. "Павлов и писатель вместе позировали художнику" - Павлов не является художником и писателем `Artist \= pavlov`, `Writer \= pavlov`
3. "Писатель написал биографическую повесть о Сахарове и собирается написать о Воронове" - Воронов и Сахаров не могут быть писателями, ведь здесь не идет речи об автобиографической повести  `Writer \= saharov, Writer \= voronov `
4. "Воронов никогда не слышал о Левицком" - это говорит нам о том, что если Воронов художник, то Левицкий не может быть писателем (3 пункт), и наоборот `not((Artist = voronov, Writer = levitsky)), not((Writer = voronov, Artist = levitsky)). `

```prolog
remove(H,[H|T],T).
remove(X,[H|T],[H|T1]) :- remove(X, T, T1).

permute([], []).
permute(L, [H|T]) :-
    remove(H, L, R),
    permute(R, T).

do_task(Dancer, Artist, Singer, Writer) :-
    permute([Dancer, Artist, Singer, Writer], [voronov, pavlov, levitsky, saharov]),
    Singer \= voronov, Singer \= levitsky,
    Artist \= pavlov,
    Writer \= saharov, Writer \= voronov, Writer \= pavlov, 
    not((Artist = voronov, Writer = levitsky)),
    not((Writer = voronov, Artist = levitsky)).
```
Предикат `solve`, не смотря на большой объем, осуществляет только вывод ответа на задачу. Здесь используется встроенный предикат стандартного вывода `write`, который может вывести только один аргумент за один вызов и предикат `nl` для перехода на новую строку.
```prolog
solve:-
    do_task(Dancer, Artist, Singer, Writer),
    write("Dancer is "), write(Dancer), nl,
    write("Artist is "), write(Artist), nl,
    write("Singer is "), write(Singer), nl,
    write("Writer is "), write(Writer).
```

## Пример работы программы
Решение является непротиворечивым, так как находит верный и единственный ответ на задачу:
```prolog
?- solve.
Dancer is voronov
Artist is saharov
Singer is pavlov
Writer is levitsky
true ;
false.
```
## Выводы
Почти все логические задачи из второй лабораторной похожи на те, что мы иногда решали в школе, интересно наблюдать, как, используя возможности языка Prolog мы можем облегчить себе задачу перебора всевозможных вариантов. Конкретно моя задача решалась достаточно просто выводом тех же логических утверждений и построением таблицы, но не всегда бывает, что задачу проще решить вручную, чем написать к ней программу. Можно сказать, что писать программу для решения логических задач имеет смысл лишь тогда, когда необходимо работать с большим объемом данных и множеством вариантов, то есть когда понадобится продолжительный перебор.

В ходе данной лабораторной работы я задумывалась об эффективности и безопасности своей программы. Также интересным для меня было то, что, переставляя строки внутри кода, мы можем получить программу с меньшим количеством переборов. Можно сделать вывод, что часто порядок выполнения алгоритма может влиять на эффективность работы программы.
