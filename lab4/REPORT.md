#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Шевлякова С. С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение
Обработка естественных и искусственных языков, обычно, является задачей для искусственного интеллекта, которая до сих пор не решена в полной мере. Выделяют следующие методы обработки естественного языка: статистический и точный. Статистический метод основан на подсчете количества слов в тексте и не требует глубоких теоретических знаний в лингвистике, но необходима обширная математическая база. Точные методы обработки текста извлекают информацию из текста. Статистический метод является некоторой загадкой, потому что мы почти никогда не можем понять причину, по которой алгоритм сделал определенный вывод, с точным методом наоборот - мы знаем конкретное правило, которое дает такой вывод.

При разборе предложения во многих случаях возможно применения сразу нескольких правил, и необходимо осуществить перебор вариантов. В Prolog мы можем легко и коротко описать правила грамматики языка, которыми будет пользоваться программа. Именно поэтому языки логического программирования исключительно хорошо подходит для решения задачи грамматического разбора.

## Задание
Реализовать разбор фраз языка, представляющих собой положительные и отрицательные высказывания. В результате предикат должен выдавать все атомарные глубинные структуры. 

Пример
```
? - decompose(["Саша", "любит", "игрушки", ",", "но", "не", "любит", "кубики", "и", "мячи"], X).
X = likes("Саша", "игрушки").
X = not_likes("Саша", "кубики").
X = not_likes("Саша", "мячи").

? - decompose(["Ира", "не", "любит", "стихи", "и", "прозы" ",", "а", "любит", "пьесы"], X).
X = not_likes("Ира", "стихи").
X = not_likes("Ира", "прозы").
X = likes("Ира", "пьесы").
```

## Принцип решения
Для решения задачи сначала выпишем грамматику с правила перехода, где VT - терминальный словарь (словарь основных слов языка) и VN - нетерминальный словарь (набор символов, которыми обозначаются исходные элементы), под действием в этой задаче подразумевается всё предложение за исключением подлежащего:
```
VT = {слова из словаря: Саша, Ира, любит, игрушки, мячи, цветы..., 'не'}
VN = {ФРАЗА, ДЕЙСТВИЯ, ГЛАГОЛ, ГРУППА_ГЛ, СУЩ, ГРУППА_СУЩ, РАЗДЕЛИТЕЛЬ}
S = ФРАЗА
P:
ФРАЗА -> СУЩ + ДЕЙСТВИЯ
ДЕЙСТВИЯ -> ГРУППА_ГЛ | ГРУППА_ГЛ + ДЕЙСТВИЯ
ГРУППА_ГЛ -> ГЛАГОЛ + ГРУППА_СУЩ | РАЗДЕЛИТЕЛЬ + ГРУППА_ГЛ | "НЕ" + ГРУППА_ГЛ
ГРУППА_СУЩ -> СУЩ | ГРУППА_СУЩ + РАЗДЕЛИТЕЛЬ + ГРУППА_СУЩ
ГЛАГОЛ -> "любит" | ...
СУЩ -> "игрушки" | "мячи" | ...
РАЗДЕЛИТЕЛЬ -> "и" | "да" | "," | ", а" | ", но" | ", зато" 
```
При решении задачи применялись стандартные предикаты ```member```, ```length```, ```append```. Самая главная часть программы - это описание грамматики, написанной выше, также нам необходимо описать словарь, я заполнила его словами из примера:
```prolog
% словарь
nouns(['Саша', 'Ира', 'игрушки', 'кубики', 'мячи', 'стихи', 'прозы', 'пьесы']).
verbs(['любит']).
separators([['и'], ['да'], [',', 'но'], [',', 'а'], [','], [',', 'зато']]).

% называем терм для глагола
verb_to_term('любит', 'likes').
verb_to_term(['не' | 'любит'], 'not_likes').

% отделения действия от подлежащего
check_phrase([Subject | Actions], deep_st(Verb, Subject, Object)) :- 
    check_noun(Subject), 
    check_actions(Actions, Verb, Object).

% ДЕЙСТВИЯ -> ГРУППА_ГЛ
check_actions(Actions, Verb, Object) :- 
    check_verb_group(Actions, Verb, Object).

% ДЕЙСТВИЯ -> ГРУППА-ГЛ + ДЕЙСТВИЯ
check_actions(Actions, Verb, Object) :- 
    split(Actions, Verb_Group, TMP), 
    check_verb_group(Verb_Group, Verb, Object), 
    check_actions(TMP, _, _).

check_actions(Actions, Verb, Object) :- 
    split(Actions, TMP, Actions1),
    check_verb_group(TMP, _, _),
    check_actions(Actions1, Verb, Object).

% ГРУППА_ГЛ -> ГЛАГОЛ + ГРУППА_СУЩ
check_verb_group([Verb | Object_Group], Verb, Object) :- 
    check_verb(Verb),
    check_object_group(Object_Group, Object).

% ГРУППА_ГЛ -> РАЗДЕЛИТЕЛЬ + ГРУППА_ГЛ
check_verb_group([Sep | Verb_Group], Verb, Object) :- 
    check_separator([Sep]), 
    check_verb_group(Verb_Group, Verb, Object).

% ЕСЛИ РАЗДЕЛИТЕЛЬ СОДЕРЖИТ ЗАПЯТУЮ
check_verb_group([Sep1, Sep2 | Verb_Group], Verb, Object) :- 
    check_separator([Sep1, Sep2]), 
    check_verb_group(Verb_Group, Verb, Object).

% ГРУППА_ГЛ -> 'НЕ' + ГРУППА_ГЛ
check_verb_group(['не' | Verb_Group], ['не' | Verb], Object) :- 
    !, 
    check_verb_group(Verb_Group, Verb, Object).

% ГРУППА_СУЩ -> СУЩ
check_object_group([Object], Object) :- 
    check_noun(Object).

% ГРУППА_СУЩ -> ГРУППА_СУЩ + РАЗДЕЛИТЕЛЬ + ГРУППА_СУЩ 
check_object_group(Object_Group, Object) :- 
    split(Object_Group, Object_Group1, Sep, TMP), 
    length(Sep, 1), 
    check_separator(Sep), 
    check_object_group(Object_Group1, Object),
    check_object_group(TMP, _).

check_object_group(Object_Group, Object) :- 
    split(Object_Group, TMP, Sep, Object_Group2), 
    length(Sep, 1),
    check_separator(Sep), 
    check_object_group(TMP, _),
    check_object_group(Object_Group2, Object).
```
Также хочу обратить внимание, что в случае ГРУППА_ГЛ -> 'НЕ' + ГРУППА_ГЛ я использую отсечение, благодаря этому программа будет работать быстрее, потому что Prolog сможет унифицировать глагольную группу с необходимой структурой, а дальнейшие попытки унифицировать эту глагольную группу с другими правилами не даст результат.

Предикат ```decompose(Phrase, List)``` используется для взаимодействия с пользователем, благодаря встроенному предикату ```setof``` все глубинные формы вида ```deep_st(Verb, Subject, Object)``` собираются в упорядоченный список без повторений. Предикат ```decompose_phrase(Phrase, Result)``` преобразуют глубинную структуру при помощи оператора ```=...``` из вида ```deep_st(Verb, Subj, Obj)``` в ```Verb_Term(Subj, Obj)```:
```prolog
decompose(Phrase, List) :- 
    setof(Deep_st, decompose_phrase(Phrase, Deep_st), List).

decompose_phrase(Phrase, Result) :- 
    check_phrase(Phrase, deep_st(Verb, Subject, Object)), 
    verb_to_term(Verb, Verb_Term), 
    Result=..[Verb_Term, Subject, Object].
```

## Результаты
На всех тестах программа работает правильно:
```
decompose(['Саша', 'любит', 'кубики', ',', 'но', 'не', 'любит', 'мячи', 'и', 'стихи'], X).
X = [likes('Саша', кубики), not_likes('Саша', мячи), not_likes('Саша', стихи)].

decompose(['Ира', 'не', 'любит', 'стихи', 'и', 'прозы', ',', 'а', 'любит', 'пьесы' ], X).
X = [likes('Ира', пьесы), not_likes('Ира', прозы), not_likes('Ира', стихи)].

decompose(['Ира', 'любит', 'стихи', ',', 'любит', 'пьесы', ',', 'не', 'любит', 'игрушки'], X).
X = [likes('Ира', пьесы), likes('Ира', стихи), not_likes('Ира', игрушки)].

decompose(['Саша', 'не', 'любит', 'мячи', ',', 'зато', 'любит', 'стихи'],X).             
X = [likes('Саша', стихи), not_likes('Саша', мячи)].
```

## Выводы
Одними из самых распространенных задач, решаемых языками логического программирования, являются именно задачи грамматического разбора естественного языка. Это связано с естественностью реализации процесса перебора всевозможных вариантов, а также возможность бэктрекинга. В моей задаче Prolog оказался удобным, потому что, используя символьный подход, мы можем представить грамматику языка в виде фактов и правил.

Но не всегда на Prolog можно описать грамматику языку, даже в английском языке, где все предложения строятся по определенным правилам, это будет достаточно тяжело, что уж говорить о нашем родном русском языке. Можем сделать вывод, что Prolog подходит для решения задач грамматического разбора в том случае, если мы можем описать грамматику языку разумным числом правил. Если это не представляется возможным, что же, придется передать работу нейронным сетям. 

И вот наша последняя лабораторная работа, курс подошел к завершению, наконец-то я смогла увидеть связь логического программирования и нейронных сетей. Надеюсь, что полученные знания я смогу использовать в дальнейшем обучении или даже на работе, а если нет, то ничего страшного, я хотя бы напрягла свой мозг.
