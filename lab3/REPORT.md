#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Шевлякова С. С. 

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Пространство состояний возникает при разделении решения задачи на отдельные шаги. Здесь мы различаем начальное состояние, когда у нас еще нет выбранной гипотезы, а также конечное состояние, когда мы нашли гипотезу, являющуюся допустимым решением нашей задачи. В процессе поиска этой гипотезы происходят операции перехода в следующее состояние. Чтобы не обходить пространство состояний целиком при поиске решения, применяются различные алгоритмы поиска. Существует два типа – полный перебор и эвристический поиск. Различают следующие виды полного перебора: поиск в глубину, поиск в ширину и поиск с итеративным углублением.

Задачи, в которых указано начальное и конечное состояния, а также некоторые логические правила или условия перехода между состояниями, удобным образом решаются методом поиска в пространстве решений. Обычно, это бывают практические задачи, содержащие некоторое конечное множество состояний. Prolog удобен для решения таких задач, потому что задать все состояния и указать связи между ними в программе на языке Prolog можно всего в несколько строк, ведь Prolog основан на языке предикатов математической логики.

## Задание

6. Вдоль доски расположено 8 лунок, в которых лежат 4 черных и 3 белых шара. Передвинуть черные шары на место белых, а белые - на место черных. Шар можно передвинуть в соседнюю с ним пустую лунку, либо в пустую лунку, находящуюся непосредственно за ближайшим шаром. При этом черные шары можно передвигать только вправо, а белые - только влево. 

## Принцип решения

Сначала опишем возможные правила перехода из одного состояния в другое, они удовлетворяют условиям задачи: белые шары мы можем передвигать только влево, если есть свободная лунка, черные - только вправо, а также шар можно передвинуть в пустую лунку, находящуюся непосредственно за ближайшим шаром:
 ```prolog
 step(A,B):-
    append(Begin,["_","w"|Tail],A),
    append(Begin,["w","_"|Tail],B).

step(A,B):-
    append(Begin,["b","_"|Tail],A),
    append(Begin,["_","b"|Tail],B).

step(A,B):-
    append(Begin,["_","b","w"|Tail],A),
    append(Begin,["w","b","_"|Tail],B).

step(A,B):-
    append(Begin,["b","w","_"|Tail],A),
    append(Begin,["_","w","b"|Tail],B).
 ```
 
 Поиск в глубину:
 ```prolog
 dfs(Finish,[Finish|Tail]) :-
    !, print_list([Finish|Tail]).
       
dfs(Finish, [Curr|Tail]) :-
    step(Curr, New),
    not(member(New,Tail)),             
    dfs(Finish, [New, Curr|Tail]).
 ```
Предикат ```dfs``` работает следующим образом: сначала делается шаг преобразования, после проверяется, является ли данное состояние уникальным (не встречали ли мы уже такое решение), далее рекурсивно запускаем функцию. Алгоритм закончит выполнение, если в начале списка найденных решений окажется исходное решение, и выведет все этапы преобразований.

Поиск в ширину:
 ```prolog
bfs([First|_],Finish,First) :- 
    First = [Finish|_].
bfs([[LastWay|HasBeen]|OtherWays],Finish,Way):-  
    findall([Z,LastWay|HasBeen], next(LastWay, HasBeen, Z), List),
    append(List,OtherWays,NewWays), 
    bfs(NewWays,Finish,Way).
 ```
Суть работы предиката поиска в ширину ```bfs``` заключается в том, что мы продлеваем первый элемент в очереди и помещаем его в конец, если у нас появился путь, который невозможно продлить, то удаляем его из очереди, также описываем ситуацию конца поиска.
 
Поиск с итеративным погружением:
 ```prolog
id([Finish|Tail],Finish,[Finish|Tail],0).

id(TempWay,Finish,Way,N):- 
    N > 0,
    next2(TempWay,NewWay),
    N1 is N-1,
    id(NewWay,Finish,Way,N1).
 ```
Алгоритм с итеративным погружением ```id``` совмещает в себе признаки и алгоритма поиска в ширину, и алгоритма поиска в глубину. Так как он, с одной стороны, рекурсивен и опускается вглубь а, с другой стороны, он находит варианты ответа от меньшего к большему. При самом поиске решений, мы проверяем, что количество оставшихся шагов больше нуля, и если это так, то мы продлеваем пройденный путь, уменьшаем количество оставшихся шагов и пытаемся найти путь из следующего состояния. Параметр N ограничивает глубину поиска, если на этом уровне глубины не найдется ни одно решение, то N будет увеличено в цикле.

Также в программе реализованы предикаты для вывода решения ```print_list``` и времени работы алгоритма ```get_time```:
 ```prolog
 solve(Start, Finish):-
    writeln('DFID'),
    get_time(S1),
    for(Lvl, 1, 20),
    id([Start], Finish, Way, Lvl),
    print_list(Way),
    get_time(R1),
    T1 is R1 - S1,
    write('Time is '), writeln(T1), nl,

    writeln('DFS'),
    get_time(S2),
    dfs(Finish, [Start]),
    get_time(R2),
    T2 is R2 - S2,
    write('Time is '), writeln(T2), nl,

    writeln('BFS'),
    get_time(S3),
    bfs([[Start]],Finish,Way), 
    print_list(Way),
    get_time(R3),
    T3 is R3 - S3,
    write('Time is '), writeln(T3),
    !.
 ```
 
## Результаты

```prolog
?- solve(["b","b","b","b","_","w","w","w"],["w","w","w","_","b","b","b","b"]).
DFID
[b,b,b,b,_,w,w,w]
[b,b,b,b,w,_,w,w]
[b,b,b,_,w,b,w,w]
[b,b,_,b,w,b,w,w]
[b,b,w,b,_,b,w,w]
[b,b,w,b,w,b,_,w]
[b,b,w,b,w,b,w,_]
[b,b,w,b,w,_,w,b]
[b,b,w,_,w,b,w,b]
[b,_,w,b,w,b,w,b]
[_,b,w,b,w,b,w,b]
[w,b,_,b,w,b,w,b]
[w,b,w,b,_,b,w,b]
[w,b,w,b,w,b,_,b]
[w,b,w,b,w,_,b,b]
[w,b,w,_,w,b,b,b]
[w,_,w,b,w,b,b,b]
[w,w,_,b,w,b,b,b]
[w,w,w,b,_,b,b,b]
[w,w,w,_,b,b,b,b]
Time is 0.03806304931640625

DFS
[b,b,b,b,_,w,w,w]
[b,b,b,b,w,_,w,w]
[b,b,b,_,w,b,w,w]
[b,b,_,b,w,b,w,w]
[b,b,w,b,_,b,w,w]
[b,b,w,b,w,b,_,w]
[b,b,w,b,w,b,w,_]
[b,b,w,b,w,_,w,b]
[b,b,w,_,w,b,w,b]
[b,_,w,b,w,b,w,b]
[_,b,w,b,w,b,w,b]
[w,b,_,b,w,b,w,b]
[w,b,w,b,_,b,w,b]
[w,b,w,b,w,b,_,b]
[w,b,w,b,w,_,b,b]
[w,b,w,_,w,b,b,b]
[w,_,w,b,w,b,b,b]
[w,w,_,b,w,b,b,b]
[w,w,w,b,_,b,b,b]
[w,w,w,_,b,b,b,b]
Time is 0.009315967559814453

BFS
[b,b,b,b,_,w,w,w]
[b,b,b,b,w,_,w,w]
[b,b,b,_,w,b,w,w]
[b,b,_,b,w,b,w,w]
[b,b,w,b,_,b,w,w]
[b,b,w,b,w,b,_,w]
[b,b,w,b,w,b,w,_]
[b,b,w,b,w,_,w,b]
[b,b,w,_,w,b,w,b]
[b,_,w,b,w,b,w,b]
[_,b,w,b,w,b,w,b]
[w,b,_,b,w,b,w,b]
[w,b,w,b,_,b,w,b]
[w,b,w,b,w,b,_,b]
[w,b,w,b,w,_,b,b]
[w,b,w,_,w,b,b,b]
[w,_,w,b,w,b,b,b]
[w,w,_,b,w,b,b,b]
[w,w,w,b,_,b,b,b]
[w,w,w,_,b,b,b,b]
Time is 0.011686086654663086
true.
```
| Алгоритм поиска |  Длина найденного первым пути  |  Время работы  |
|-----------------|--------------------------------|----------------|
| В глубину       |               20               |  0.00931       |
| В ширину        |               20               |  0.01168       |
| ID              |               20               |  0.01002       |

## Выводы
В этой лабораторной работе было достаточно просто задать правила перехода. Сложность вызвало написание поисков несмотря на то, что они были известны мне из курса программирования. Оказалось, что код алгоритма на Prolog более понятен по сравнению с другими языками программирования. Были написаны три алгоритма поиска: в глубину, в ширину и с итеративным погружением. Все три алгоритма справились со своей задачей, но наиболее эффективно, как видно по результатам времени оказался поиск с итеративным погружением. Он является симбиозом первых двух, что позволяет ему наследовать как преимущества, так и недостатки обоих. Но это не значит, что в другой задаче поиск в глубину с ограничением окажется оптимальным. Если я, например, изменю значение максимальной глубины до 1000, то алгоритм будет работать дольше, поэтому необходим предварительный анализ. Выбирая алгоритм для решения задачи стоит отталкиваться от конкретных условий.
